[{"content":"Lấy Lại Dữ Liệu Sau Khi Xóa Giới thiệu Bạn đã bao giờ nhỡ tay xóa mất một bảng (DROP TABLE) hoặc xóa sạch dữ liệu trong bảng (DELETE) của một database đang hoạt động rất nhộn nhịp, để rồi giật mình nhận ra mình vừa phạm một lỗi tày đình? Mồ hôi vã ra đầm đìa, nghe chuông điện thoại kêu mà giật mình thon thót, đầu óc quay cuồng nghĩ cách ăn nói thế nào cho phải. Những hoàn cảnh tương tự như vậy không phải hiếm. Đối với các DBA thường xuyên phải làm việc trực tiếp trên dữ liệu, những sự cố xảy ra do nhầm lẫn là không tránh khỏi. Rất may SQL Server đã tính đến tình huống này, và cung cấp các phương tiện cần thiết để lấy lại dữ liệu, với điều kiện database phải có những thiết lập đúng đắn từ trước. Tuy nhiên bạn có thể thấy là vấn đề đã trở nên phức tạp hơn, câu lệnh không thể ROLLBACK lại được nữa vì SQL Server để chế độ mặc định là AUTO COMMIT. Khôi phục lại từ bản backup từ ngày hôm trước cũng không giải quyết được, vì như thế dữ liệu vừa mới được cập nhật trong ngày cũng sẽ mất tiêu luôn. Vấn đề đặt ra là cần lấy lại dữ liệu giống như thời điểm ngay trước khi chạy lệnh DELETE, chứ không phải từ ngày hôm qua. Một gợi ý cho bạn: log file luôn lưu lại tất cả các hành động diễn ra đối với database, bao gồm cả lệnh DELETE vừa xong. Đây là dấu vết duy nhất và cách làm của ta cũng là dựa vào đó để lần ngược lại.\nĐiều kiện để có thể phục hồi Để có thể khôi phục lại được đòi hỏi ba điều kiện sau:\n database có chế độ RECOVERY MODE là FULL database đã từng được FULL BACKUP và bạn có trong tay file backup gần nhất log file chưa từng bị SHRINK kể từ sau lần full backup gần nhất. Nếu một trong ba điều kiện trên bị vi phạm thì vấn đề kể như hết cách giải cứu. Giả sử cả ba điều kiện trên được thỏa mãn và lần full backup gần đây nhất là đêm hôm trước. Bạn có thể khôi phục thông qua các bước sau (xem thêm script ở phần dưới):  Đóng lại tất cả các kết nối đến database để không tiếp nhận thêm dữ liệu Ghi lại thời điểm xảy ra lệnh DELETE lỗi Thực hiện BACKUP LOG cho database Khôi phục lại database theo trình tự sau:  RESTORE từ bản full backup đêm hôm trước RESTORE từ bản log backup với lựa chọn STOPAT = thời điểm ngay trước khi có sự cố      Và khi mọi việc đã hoàn tất, chuyển lại database sang chế độ hoạt động bình thường để các ứng dụng lại có thể kết nối vào database.\nThực hiện Script Tạo database và bảng:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  USEmasterGOIFDB_ID(\u0026#39;TestDB\u0026#39;)ISNOTNULLDROPDATABASETestDBGOCREATEDATABASETestDBGOUSETestDBGOCREATETABLEdbo.Table1(IDINTIDENTITY,TenVARCHAR(30))GOINSERTINTOdbo.Table1(Ten)SELECT\u0026#39;Nguyen Van A\u0026#39;UNIONALLSELECT\u0026#39;Nguyen Van B\u0026#39;UNIONALLSELECT\u0026#39;Nguyen Van C\u0026#39;  Thực hiện full backup:\n1 2 3 4 5  BACKUPDATABASETestDBTODISK=\u0026#39;D:\\Backup\\TestDB.bak\u0026#39;WITHINITThêmdữliệumớisaukhifullbackup:INSERTINTOdbo.Table1(Ten)SELECT\u0026#39;Nguyen Van D\u0026#39;UNIONALLSELECT\u0026#39;Nguyen Van E\u0026#39;  Ba đoạn lệnh trên mô phỏng tình huống thực tế một database đã có chứa dữ liệu, được backup full lúc nửa đêm hôm trước, và trong ngày đã có thêm dữ liệu mới. Tại một thời điểm nào đó trong ngày bạn xóa mất dữ liệu do sơ suất:\n1  DELETEFROMdbo.Table1  Sau khi xảy ra sự cố, việc tiếp theo đầu tiên bạn cần làm là đóng lại database, để không ai có thể tiếp tục cập nhật dữ liệu đến khi database được khôi phục xong. Bạn làm việc này bằng cách chuyển database về trạng thái SINGLE_USER (một người dùng). Vì bạn đang kết nối vào database, không ai khác có thể kết nối được nữa:\n1  ALTERDATABASETestDBSETSINGLE_USERWITHROLLBACKIMMEDIATE  Sau đó ghi lại thời điểm xảy ra sự cố:\n1  SELECTGETDATE()  Khi đang chạy script cho bài viết này, thời điểm hiện tại của tôi là ’2010-12-07 17:51:03.990′. Việc tiếp theo là backup log:\n1  BACKUPLOGTestDBTODISK=\u0026#39;D:\\backup\\TestDB.trn\u0026#39;WITHINIT  Sau đó khôi phục lại database theo thứ tự bản full backup trước rồi đến bản log backup:\n1 2 3 4 5  USEmastergoRESTOREDATABASETestDBFROMDISK=\u0026#39;D:\\backup\\TestDB.bak\u0026#39;WITHNORECOVERYRESTOREDATABASETestDBFROMDISK=\u0026#39;D:\\backup\\TestDB.trn\u0026#39;WITHSTOPAT=\u0026#39;2010-12-07 17:50:00\u0026#39;  Điểm mấu chốt trong đoạn lệnh trên là mệnh đề STOPAT ở lệnh RESTORE thứ hai. Mục đích của nó là khôi phục lại database từ log backup nhưng dừng lại tại thời điểm được chỉ định. Khi các hành động xảy ra đối với database được lưu vào log file, nó cũng kèm theo thời điểm xảy ra hành động đó. Khi backup log file thì bản backup cũng chứa y nguyên các thông tin này. Vì thế khi restore từ log file với mệnh đề STOPAT, bạn đã yêu cầu hệ thống “tua” lại các hành động đã được áp dụng đối với database, nhưng dừng lại trước thời điểm có sự cố. Do đó lệnh DELETE trên không được thực hiện lại và bảng đã trở về trạng thái như cũ. Hãy để ý ở mệnh đề STOPAT, tôi đã đẩy lùi thời gian lại một chút để đảm bảo thời điểm đó là trước khi xảy ra xóa dữ liệu. Khi chạy thử nghiệm bạn cần lưu ý điều này và chọn thời điểm cho thích hợp. Và dữ liệu đã được khôi phục:\n1 2 3 4 5 6 7 8 9 10 11 12 13  USETestDBGOSELECT*FROMdbo.Table1IDTen----------- ------------------------------ 1NguyenVanA2NguyenVanB3NguyenVanC4NguyenVanD5NguyenVanE(5ROW(s)affected)  Bước cuối cùng là chuyển lại database sang chế độ bình thường\n1  ALTERDATABASETestDBSETMULTI_USER  Vậy là vấn đề đã được giải quyết (sau khoảng nửa tiếng đến 1 tiếng gián đoạn sử dụng). Bây giờ là một câu hỏi giành cho bạn: Trong ví dụ trên tôi giả sử database chỉ có một backup duy nhất vào nửa đêm, và đó là full backup. Nếu ngoài ra database còn có các log backup định kỳ trong ngày (ví dụ mỗi tiếng 1 lần), thì việc khôi phục cần được thực hiện như thế nào?\nCác bước thực hiện:\n Thực hiện Restore Full backup từ lúc nửa đêm Sau đó thực hiện restore các backup định kỳ theo đúng thứ tự Bước cuối cùng là RESTORE với tùy chọn STOPAT như trong bài đã hướng dẫn Vâng đúng là như vậy. Một điều nữa là khi đó lệnh backup log ở trong ví dụ trên cần bỏ lựa chọn \u0026ldquo;WITH INIT\u0026rdquo; hoặc cần backup vào một file riêng (khác với file dùng trong các backup định kỳ)  Tham khảo Thầy Lưu Nguyễn Kỳ Thư\nĐây là đồ án mà tôi đã thực hiện để demo vấn đề này. backup-restore\n  ","date":"2022-05-19T00:00:00Z","image":"https://truongnh28.github.io/p/backup-and-restore/backup-restore-mssql-database_huedd795790a66a116bf38eeeb4dcb7687_88649_120x120_fill_q75_box_smart1.jpg","permalink":"https://truongnh28.github.io/p/backup-and-restore/","title":"Backup and Restore"},{"content":"Class diagram Giới thiệu Sơ đồ lớp (UML) là một ký hiệu đồ họa sử dụng để trực quan hóa các hệ thống hướng đối tượng. Sơ đồ lớp trong UML là một loại sơ đồ cấu trúc tĩnh mô tả cấu trúc của hệ thống bằng cách hiển thị các thành phần của các thành phần hệ thống:\n Các lớp Các thuộc tính của lớp. Các phương thức của lớp. Các quan hệ giữa các đối tượng.  Class là cái vẹo gì? Class là một bản thiết kế cho một đối tượng. Các đối tượng và class luôn đi đôi với nhau. Chúng ta không thể nói cái này mà không có cái kia. Và toàn bộ điểm của thiết kế hướng đối tượng không phải nói đến các đối tượng mà nó nói đến class bởi vì chúng ta sử dụng class để tạo ra các đối tượng. Nên một class sẽ mô tả một đối tượng nó như thế nào nhưng bản thân của class không phải là một đối tượng.\nTrong thực tế, các class mô tả các kiểu của đối tượng, trong khi các đối tượng là thể hiện của các class. Mỗi đối tượng được xây dựng từ các bản thiết kế do đó nó chứa các phương thức và thuộc tính giống nhau. Ý nghĩa tiêu chuẩn là một đối tượng là một thể hiện của một lớp và các đối tượng có trạng thái và hành vi.\nVí dụ:\nKý hiệu của UML Class Một class đại diện cho một khái niệm bao gồm thuộc tính (attributes) và hành vi(behavior). Mỗi thuộc tính có một kiểu và một hành vi mỗi hành vi có một chữ ký. Tên lớp là thông tin bắt buộc duy nhất.\n Tên lớp:  Tên của lớp xuất hiện trong phân vùng đầu tiên.   Thuộc tính lớp(Attributes):  Các thuộc tính được hiển thị trong phân vùng thứ hai. Loại thuộc tính được hiển thị sau dấu hai chấm. Các thuộc tính ánh xạ lên các biến thành viên (thành viên dữ liệu) trong mã.   Hoạt động lớp(Operations) (Phương thức):   Các hoạt động được hiển thị trong phân vùng thứ ba. Chúng là những dịch vụ mà lớp học cung cấp.\n  Kiểu trả về của một phương thức được hiển thị sau dấu hai chấm ở cuối chữ ký phương thức.\n  Kiểu trả về của các tham số phương thức được hiển thị sau dấu hai chấm theo sau tên tham số. Các phép toán ánh xạ vào các phương thức lớp trong code.\n      Class Visibility\nCác ký hiệu +, - và # trước tên thuộc tính và hoạt động trong một lớp biểu thị khả năng hiển thị của thuộc tính và hoạt động.\n \u0026ldquo;+\u0026rdquo; biểu thị các thuộc tính hoặc hoạt động public \u0026ldquo;-\u0026rdquo; biểu thị các thuộc tính hoặc hoạt động private \u0026ldquo;#\u0026rdquo; biểu thị các thuộc tính hoặc hoạt động protected    Parameter Directionality\nMỗi tham số trong một hoạt động (phương thức) có thể được ký hiệu là in, out hoặc inout, chỉ định hướng của nó đối với người gọi. Hướng này được hiển thị trước tên tham số.\n  Perspectives of Class Diagram Việc lựa chọn quan điểm phụ thuộc vào việc bạn đã đi được bao xa trong quá trình phát triển. Ví dụ, trong quá trình xây dựng domain model, bạn sẽ hiếm khi vượt qua conceptual perspective. Analysis models thường sẽ có sự kết hợp giữa conceptual and specification perspectives. Việc phát triển Design model thường sẽ bắt đầu với sự nhấn mạnh nhiều vào specification perspective, và phát triển thành implementation perspective.\nMột sơ đồ có thể được giải thích từ nhiều khía cạnh khác nhau:\n Conceptual(Khái niệm): đại diện cho các khái niệm trong miền Specification(Đặc điểm kỹ thuật): tập trung vào các giao diện của Kiểu dữ liệu trừu tượng (ADT) trong phần mềm Implementation(Triển khai): mô tả cách các lớp sẽ triển khai các giao diện của chúng  Quan điểm ảnh hưởng đến số lượng chi tiết được cung cấp và các loại mối quan hệ đáng trình bày. Như chúng tôi đã đề cập ở trên, tên lớp là thông tin bắt buộc duy nhất.\nMối quan hệ giữa các lớp UML không chỉ là về những bức ảnh đẹp. Nếu được sử dụng đúng cách, UML sẽ truyền tải chính xác cách mà code nên được triển khai từ các sơ đồ. Nếu được diễn giải chính xác, code được triển khai sẽ phản ánh đúng ý định của nhà thiết kế. Bạn có thể mô tả ý nghĩa của từng mối quan hệ so với ngôn ngữ lập trình mục tiêu của bạn được hiển thị trong Hình bên dưới không?\nNếu bạn vẫn chưa thể nhận ra chúng, không có vấn đề gì phần này nhằm giúp bạn hiểu các mối quan hệ lớp UML. Một lớp có thể tham gia vào một hoặc nhiều mối quan hệ với các lớp khác. Mối quan hệ có thể là một trong các loại sau:\nInheritance (or Generalization) (Kế thừa (hoặc Tổng quát)) Tổng quát hóa là một mối quan hệ phân loại giữa một bộ phân loại tổng quát hơn và một bộ phân loại cụ thể hơn. Mỗi thể hiện của trình phân loại cụ thể cũng là một thể hiện gián tiếp của trình phân loại chung. Do đó, trình phân loại cụ thể kế thừa các tính năng của trình phân loại tổng quát hơn.\nVí dụ: Hình dưới đây cho thấy một ví dụ kế thừa với hai kiểu. Mặc dù các đầu nối được vẽ khác nhau nhưng chúng tương đương nhau về mặt ngữ nghĩa.\nAssociation (Sự kết hợp) Liên kết là mối quan hệ giữa các lớp trong một Sơ đồ lớp UML. Chúng được biểu diễn bằng một đường liền nét giữa các lớp. Các liên kết thường được đặt tên bằng cách sử dụng một động từ hoặc cụm động từ phản ánh lĩnh vực vấn đề trong thế giới thực.\na. Hiệp hội đơn giản\n Một liên kết cấu trúc giữa hai lớp đồng đẳng. Có sự liên kết giữa Class1 và Class2  Hình dưới đây cho thấy một ví dụ về liên kết đơn giản. Có một liên kết kết nối lớp \u0026laquo;control\u0026raquo; lớp Class1 và lớp \u0026laquo;boundary\u0026raquo; lớp Class2. Mối quan hệ được hiển thị như một đường liền mạch nối hai lớp.\nb. Cardinality\nCardinality được thể hiện dưới dạng:\n Một - Một Một - Nhiều Nhiều - Nhiều.   Aggregation (Tổng hợp) Một kiểu liên kết đặc biệt.\n Nó đại diện cho một mối quan hệ \u0026ldquo;một phần của\u0026rdquo;. Class2 là một phần của Class1. Nhiều phiên bản (ký hiệu là *) của Class2 có thể được liên kết với Class1. Các đối tượng của Class1 và Class2 có vòng đời riêng biệt.  Hình dưới đây cho thấy một ví dụ về tập hợp. Mối quan hệ được hiển thị dưới dạng một đường liền nét với một viên kim cương chưa được lấp đầy ở đầu kết hợp, được kết nối với lớp đại diện cho tổng thể. Composition (Hợp thành)  Một kiểu tập hợp đặc biệt mà các bộ phận bị phá hủy khi toàn bộ bị phá hủy. Các đối tượng của Class2 sống chết với Class1. Class2 không thể tự đứng.  Hình dưới đây cho thấy một ví dụ về bố cục. Mối quan hệ được hiển thị dưới dạng một đường liền nét với một viên kim cương được lấp đầy ở đầu kết hợp, được kết nối với lớp đại diện cho toàn bộ hoặc kết hợp. Dependency (Sự phụ thuộc) Một đối tượng của một lớp có thể sử dụng một đối tượng của lớp khác trong mã của một phương thức. Nếu đối tượng không được lưu trữ trong bất kỳ trường nào, thì đối tượng này được mô hình hóa như một mối quan hệ phụ thuộc.\n Một kiểu liên kết đặc biệt. Tồn tại giữa hai lớp nếu những thay đổi đối với định nghĩa của một lớp có thể gây ra những thay đổi cho lớp kia (nhưng không phải ngược lại). Class1 phụ thuộc vào Class2  Hình dưới đây cho thấy một ví dụ về sự phụ thuộc. Mối quan hệ được hiển thị dưới dạng đường đứt nét với một mũi tên mở. Hình dưới đây cho thấy một ví dụ khác về sự phụ thuộc. Lớp Person có thể có phương thức hasRead với tham số Book trả về true nếu người đó đã đọc sách (có thể bằng cách kiểm tra một số cơ sở dữ liệu). Realization (Hiện thực hóa) Hiện thực hóa là một mối quan hệ giữa lớp kế hoạch chi tiết và đối tượng chứa các chi tiết mức độ thực thi tương ứng của nó. Đối tượng này được cho là nhận ra lớp kế hoạch chi tiết. Nói cách khác, bạn có thể hiểu đây là mối quan hệ giữa interface và lớp thực thi.\nVí dụ: giao diện Chủ sở hữu có thể chỉ định các phương pháp mua tài sản và định đoạt tài sản. Các lớp Person và Corporation cần triển khai các phương thức này, có thể theo những cách rất khác nhau. Ví dụ: Sơ đồ lớp Hệ thống đặt hàng. Ví dụ: Sơ đồ lớp: GUI Sơ đồ lớp cũng có thể có các ghi chú đính kèm với các lớp hoặc các mối quan hệ. Tham khảo visual-paradigm\n  ","date":"2022-05-14T00:00:00Z","image":"https://truongnh28.github.io/p/class-diagram-uml/p18_hu677a00736f2dcfd7487ef442f4d9b9a7_160760_120x120_fill_box_smart1_3.png","permalink":"https://truongnh28.github.io/p/class-diagram-uml/","title":"Class diagram UML"},{"content":"Đề bài: Thiết kế một hệ thống web blog với khả năng chịu tải 10000 request trên giây. Bài làm Phát thảo các trường hợp sử dụng và các ràng buộc Trường hợp sử dụng Ta sẽ giải quyết các trường hợp sau:\n Người dùng thực hiện yêu cầu đọc hoặc ghi  Dịch vụ xử lý, lưu trữ dữ liệu người dùng sau đó trả kết quả.   Hệ thống có tính chịu tải lớn. Hệ thống có tính khả dụng cao.  Hạn chế và giả định   Giả định trạng thái\n Lưu lượng truy cập phân bố không đồng đều. Cần cơ sở dữ liệu quan hệ. Quy mô từ 1 đến hàng triệu người dùng. 1 triệu người dùng. 1 triệu lượt viết mỗi tháng. 500 triệu lượt đọc mỗi tháng Tỷ lệ đọc ghi là: 500 : 1 Dung lượng khoảng 500kb    Tính toán mức sử dụng\n 476 GB nội dung mỗi tháng.  500 KB * 1000000 lần ghi mỗi tháng. Giả sử hầu hết các bài viết là nội dung mới thay vì cập nhật những nội dung đã có.   Trung bình 10 giây thì có 4 lần viết. Trung bình 1 giây thì có 200 lần đọc. 10000 request mỗi giây -\u0026gt; 25000000000 request mỗi tháng.    Thiết kế ở mức cao hơn Thiết kế các thanh phần cốt lõi Người dùng yêu cầu đọc hoặc ghi.\nVới số lượng người dùng nhỏ:\n Chỉ cần một Web Server duy nhất. Có thể dùng vertical scaling khi cần thiết. Giám sát để xử lý hệ thống nếu xảy ra hiện tượng tắt nghẽn.   Một Web Server duy nhất:  Lưu trữ dữ liệu của người dùng. Xử lý các yêu cầu. Lưu trữ database MySQL.   Sử dụng vertical scaling:  Đơn giản chỉ cần chọn một hộp lớn hơn. Theo dõi các chỉ số để xác định cách mở rộng quy mô. Sử dụng giám sát cơ bản để xác định tắc nghẽn: CPU, bộ nhớ, IO, mạng, v.v. Mở rộng quy mô theo chiều dọc có thể rất tốn kém. Không có backup.   Cơ sở dữ liệu MySQL:  Các ràng buộc cần có cơ sở dữ liệu quan hệ. Dùng MySQL chung trên Web Server.   DNS  Gán IP của Web Server với một tên miền.   Bảo mật Web Server  Chỉ mở các cổng cần thiết.  Cho phép máy chủ web phản hồi các yêu cầu đến từ:  80 cho HTTP. 443 cho HTTPS. 22 cho SSH đến chỉ các IP có trong danh sách cho phép.   Ngăn Web Server có các kết nối ra.      Mở rộng thiết kế  Mở rộng Web Server theo horizontal scaling.  Sử dụng nhiều Web Server. Thêm các Load Balancer như HAProxy. Mở rộng SQL theo dạng phân tán.   Ta sử dụng CDN  Sử dụng Object Store để quản lý nội dung tĩnh.  Khả năng mở rộng cao và đáng tin cậy. Mã hóa phía máy chủ.   Di chuyển các nội dung tĩnh vào đây:  User file. JS. CSS. Hình ảnh. Video.     Thêm một Memory Caching (Redis)  Data được truy cập thường xuyên từ database. Data session từ Web Server.   Mở rộng Database  Chỉ lưu trữ dữ liệu trong một khoảng thời gian giới hạn trong cơ sở dữ liệu, trong khi lưu trữ phần còn lại trong một kho dữ liệu chẳng hạn như Redshift.  Một kho dữ liệu như Redshift có thể thoải mái xử lý giới hạn 1 TB nội dung mới mỗi tháng.   Với 200 yêu cầu đọc trung bình mỗi giây, lưu lượng đọc cho nội dung phổ biến có thể được giải quyết bằng cách mở rộng Bộ nhớ cache , điều này cũng hữu ích để xử lý lưu lượng truy cập được phân bổ không đồng đều và lưu lượng truy cập tăng đột biến.   Bảo mật hệ thống  Mã hóa dữ liệu khi chuyển tiếp và ở trạng thái nghỉ. Sử dụng VPC(Virtual Private Cloud)  Tạo một mạng con công cộng cho Web Server duy nhất để nó có thể gửi và nhận lưu lượng truy cập từ internet. Tạo một mạng con riêng cho mọi thứ khác, ngăn chặn sự truy cập từ bên ngoài. Chỉ mở các cổng từ các IP có trong danh sách cho phép cho phép.      Sắp tới mình sẽ có một bản demo về vấn đề này ở link này. Mình sẽ cố gắng cập nhật sớm nhất.\nKết luận Trên đây chỉ là hiểu biết của mình thông qua việc tìm hiểu module System Design, bản thân mình cũng hi vọng nhận được sự những chia sẻ cũng như thảo luận từ phía các bạn để hoàn thiện hơn. Xin cảm ơn.\nTham khảo system-design-primer\n","date":"2022-05-14T00:00:00Z","image":"https://truongnh28.github.io/p/system-design-project/system_design_huac571d42ebe43b23b89accb8e5d96ee3_114158_120x120_fill_box_smart1_3.png","permalink":"https://truongnh28.github.io/p/system-design-project/","title":"System Design Project"}]