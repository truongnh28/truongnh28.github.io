[{"content":"Lấy Lại Dữ Liệu Sau Khi Xóa Giới thiệu Bạn đã bao giờ nhỡ tay xóa mất một bảng (DROP TABLE) hoặc xóa sạch dữ liệu trong bảng (DELETE) của một database đang hoạt động rất nhộn nhịp, để rồi giật mình nhận ra mình vừa phạm một lỗi tày đình? Mồ hôi vã ra đầm đìa, nghe chuông điện thoại kêu mà giật mình thon thót, đầu óc quay cuồng nghĩ cách ăn nói thế nào cho phải. Những hoàn cảnh tương tự như vậy không phải hiếm. Đối với các DBA thường xuyên phải làm việc trực tiếp trên dữ liệu, những sự cố xảy ra do nhầm lẫn là không tránh khỏi. Rất may SQL Server đã tính đến tình huống này, và cung cấp các phương tiện cần thiết để lấy lại dữ liệu, với điều kiện database phải có những thiết lập đúng đắn từ trước. Tuy nhiên bạn có thể thấy là vấn đề đã trở nên phức tạp hơn, câu lệnh không thể ROLLBACK lại được nữa vì SQL Server để chế độ mặc định là AUTO COMMIT. Khôi phục lại từ bản backup từ ngày hôm trước cũng không giải quyết được, vì như thế dữ liệu vừa mới được cập nhật trong ngày cũng sẽ mất tiêu luôn. Vấn đề đặt ra là cần lấy lại dữ liệu giống như thời điểm ngay trước khi chạy lệnh DELETE, chứ không phải từ ngày hôm qua. Một gợi ý cho bạn: log file luôn lưu lại tất cả các hành động diễn ra đối với database, bao gồm cả lệnh DELETE vừa xong. Đây là dấu vết duy nhất và cách làm của ta cũng là dựa vào đó để lần ngược lại.\nĐiều kiện để có thể phục hồi Để có thể khôi phục lại được đòi hỏi ba điều kiện sau:\n database có chế độ RECOVERY MODE là FULL database đã từng được FULL BACKUP và bạn có trong tay file backup gần nhất log file chưa từng bị SHRINK kể từ sau lần full backup gần nhất. Nếu một trong ba điều kiện trên bị vi phạm thì vấn đề kể như hết cách giải cứu. Giả sử cả ba điều kiện trên được thỏa mãn và lần full backup gần đây nhất là đêm hôm trước. Bạn có thể khôi phục thông qua các bước sau (xem thêm script ở phần dưới):  Đóng lại tất cả các kết nối đến database để không tiếp nhận thêm dữ liệu Ghi lại thời điểm xảy ra lệnh DELETE lỗi Thực hiện BACKUP LOG cho database Khôi phục lại database theo trình tự sau:  RESTORE từ bản full backup đêm hôm trước RESTORE từ bản log backup với lựa chọn STOPAT = thời điểm ngay trước khi có sự cố      Và khi mọi việc đã hoàn tất, chuyển lại database sang chế độ hoạt động bình thường để các ứng dụng lại có thể kết nối vào database.\nScript Tạo database và bảng:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  USEmasterGOIFDB_ID(\u0026#39;TestDB\u0026#39;)ISNOTNULLDROPDATABASETestDBGOCREATEDATABASETestDBGOUSETestDBGOCREATETABLEdbo.Table1(IDINTIDENTITY,TenVARCHAR(30))GOINSERTINTOdbo.Table1(Ten)SELECT\u0026#39;Nguyen Van A\u0026#39;UNIONALLSELECT\u0026#39;Nguyen Van B\u0026#39;UNIONALLSELECT\u0026#39;Nguyen Van C\u0026#39;  Thực hiện full backup:\n1 2 3 4 5  BACKUPDATABASETestDBTODISK=\u0026#39;D:\\Backup\\TestDB.bak\u0026#39;WITHINITThêmdữliệumớisaukhifullbackup:INSERTINTOdbo.Table1(Ten)SELECT\u0026#39;Nguyen Van D\u0026#39;UNIONALLSELECT\u0026#39;Nguyen Van E\u0026#39;  Ba đoạn lệnh trên mô phỏng tình huống thực tế một database đã có chứa dữ liệu, được backup full lúc nửa đêm hôm trước, và trong ngày đã có thêm dữ liệu mới. Tại một thời điểm nào đó trong ngày bạn xóa mất dữ liệu do sơ suất:\n1  DELETEFROMdbo.Table1  Sau khi xảy ra sự cố, việc tiếp theo đầu tiên bạn cần làm là đóng lại database, để không ai có thể tiếp tục cập nhật dữ liệu đến khi database được khôi phục xong. Bạn làm việc này bằng cách chuyển database về trạng thái SINGLE_USER (một người dùng). Vì bạn đang kết nối vào database, không ai khác có thể kết nối được nữa:\n1  ALTERDATABASETestDBSETSINGLE_USERWITHROLLBACKIMMEDIATE  Sau đó ghi lại thời điểm xảy ra sự cố:\n1  SELECTGETDATE()  Khi đang chạy script cho bài viết này, thời điểm hiện tại của tôi là ’2010-12-07 17:51:03.990′. Việc tiếp theo là backup log:\n1  BACKUPLOGTestDBTODISK=\u0026#39;D:\\backup\\TestDB.trn\u0026#39;WITHINIT  Sau đó khôi phục lại database theo thứ tự bản full backup trước rồi đến bản log backup:\n1 2 3 4 5  USEmastergoRESTOREDATABASETestDBFROMDISK=\u0026#39;D:\\backup\\TestDB.bak\u0026#39;WITHNORECOVERYRESTOREDATABASETestDBFROMDISK=\u0026#39;D:\\backup\\TestDB.trn\u0026#39;WITHSTOPAT=\u0026#39;2010-12-07 17:50:00\u0026#39;  Điểm mấu chốt trong đoạn lệnh trên là mệnh đề STOPAT ở lệnh RESTORE thứ hai. Mục đích của nó là khôi phục lại database từ log backup nhưng dừng lại tại thời điểm được chỉ định. Khi các hành động xảy ra đối với database được lưu vào log file, nó cũng kèm theo thời điểm xảy ra hành động đó. Khi backup log file thì bản backup cũng chứa y nguyên các thông tin này. Vì thế khi restore từ log file với mệnh đề STOPAT, bạn đã yêu cầu hệ thống “tua” lại các hành động đã được áp dụng đối với database, nhưng dừng lại trước thời điểm có sự cố. Do đó lệnh DELETE trên không được thực hiện lại và bảng đã trở về trạng thái như cũ. Hãy để ý ở mệnh đề STOPAT, tôi đã đẩy lùi thời gian lại một chút để đảm bảo thời điểm đó là trước khi xảy ra xóa dữ liệu. Khi chạy thử nghiệm bạn cần lưu ý điều này và chọn thời điểm cho thích hợp. Và dữ liệu đã được khôi phục:\n1 2 3 4 5 6 7 8 9 10 11 12 13  USETestDBGOSELECT*FROMdbo.Table1IDTen----------- ------------------------------ 1NguyenVanA2NguyenVanB3NguyenVanC4NguyenVanD5NguyenVanE(5ROW(s)affected)  Bước cuối cùng là chuyển lại database sang chế độ bình thường\n1  ALTERDATABASETestDBSETMULTI_USER  Vậy là vấn đề đã được giải quyết (sau khoảng nửa tiếng đến 1 tiếng gián đoạn sử dụng). Bây giờ là một câu hỏi giành cho bạn: Trong ví dụ trên tôi giả sử database chỉ có một backup duy nhất vào nửa đêm, và đó là full backup. Nếu ngoài ra database còn có các log backup định kỳ trong ngày (ví dụ mỗi tiếng 1 lần), thì việc khôi phục cần được thực hiện như thế nào?\nCác bước thực hiện:\n Thực hiện Restore Full backup từ lúc nửa đêm Sau đó thực hiện restore các backup định kỳ theo đúng thứ tự Bước cuối cùng là RESTORE với tùy chọn STOPAT như trong bài đã hướng dẫn Vâng đúng là như vậy. Một điều nữa là khi đó lệnh backup log ở trong ví dụ trên cần bỏ lựa chọn \u0026ldquo;WITH INIT\u0026rdquo; hoặc cần backup vào một file riêng (khác với file dùng trong các backup định kỳ)    ","date":"2022-05-19T00:00:00Z","image":"https://truongnh28.github.io/p/backup-and-restore/backup-restore-mssql-database_huedd795790a66a116bf38eeeb4dcb7687_88649_120x120_fill_q75_box_smart1.jpg","permalink":"https://truongnh28.github.io/p/backup-and-restore/","title":"Backup and Restore"},{"content":"Đề bài: Thiết kế một hệ thống web blog với khả năng chịu tải 10000 request trên giây. Bài làm Phát thảo các trường hợp sử dụng và các ràng buộc Trường hợp sử dụng Ta sẽ giải quyết các trường hợp sau:\n Người dùng thực hiện yêu cầu đọc hoặc ghi  Dịch vụ xử lý, lưu trữ dữ liệu người dùng sau đó trả kết quả.   Hệ thống có tính chịu tải lớn. Hệ thống có tính khả dụng cao.  Hạn chế và giả định   Giả định trạng thái\n Lưu lượng truy cập phân bố không đồng đều. Cần cơ sở dữ liệu quan hệ. Quy mô từ 1 đến hàng triệu người dùng. 1 triệu người dùng. 1 triệu lượt viết mỗi tháng. 500 triệu lượt đọc mỗi tháng Tỷ lệ đọc ghi là: 500 : 1 Dung lượng khoảng 500kb    Tính toán mức sử dụng\n 476 GB nội dung mỗi tháng.  500 KB * 1000000 lần ghi mỗi tháng. Giả sử hầu hết các bài viết là nội dung mới thay vì cập nhật những nội dung đã có.   Trung bình 10 giây thì có 4 lần viết. Trung bình 1 giây thì có 200 lần đọc. 10000 request mỗi giây -\u0026gt; 25000000000 request mỗi tháng.    Thiết kế ở mức cao hơn Thiết kế các thanh phần cốt lõi Người dùng yêu cầu đọc hoặc ghi.\nVới số lượng người dùng nhỏ:\n Chỉ cần một Web Server duy nhất. Có thể dùng vertical scaling khi cần thiết. Giám sát để xử lý hệ thống nếu xảy ra hiện tượng tắt nghẽn.   Một Web Server duy nhất:  Lưu trữ dữ liệu của người dùng. Xử lý các yêu cầu. Lưu trữ database MySQL.   Sử dụng vertical scaling:  Đơn giản chỉ cần chọn một hộp lớn hơn. Theo dõi các chỉ số để xác định cách mở rộng quy mô. Sử dụng giám sát cơ bản để xác định tắc nghẽn: CPU, bộ nhớ, IO, mạng, v.v. Mở rộng quy mô theo chiều dọc có thể rất tốn kém. Không có backup.   Cơ sở dữ liệu MySQL:  Các ràng buộc cần có cơ sở dữ liệu quan hệ. Dùng MySQL chung trên Web Server.   DNS  Gán IP của Web Server với một tên miền.   Bảo mật Web Server  Chỉ mở các cổng cần thiết.  Cho phép máy chủ web phản hồi các yêu cầu đến từ:  80 cho HTTP. 443 cho HTTPS. 22 cho SSH đến chỉ các IP có trong danh sách cho phép.   Ngăn Web Server có các kết nối ra.      Mở rộng thiết kế  Mở rộng Web Server theo horizontal scaling.  Sử dụng nhiều Web Server. Thêm các Load Balancer như HAProxy. Mở rộng SQL theo dạng phân tán.   Ta sử dụng CDN  Sử dụng Object Store để quản lý nội dung tĩnh.  Khả năng mở rộng cao và đáng tin cậy. Mã hóa phía máy chủ.   Di chuyển các nội dung tĩnh vào đây:  User file. JS. CSS. Hình ảnh. Video.     Thêm một Memory Caching (Redis)  Data được truy cập thường xuyên từ database. Data session từ Web Server.   Mở rộng Database  Chỉ lưu trữ dữ liệu trong một khoảng thời gian giới hạn trong cơ sở dữ liệu, trong khi lưu trữ phần còn lại trong một kho dữ liệu chẳng hạn như Redshift.  Một kho dữ liệu như Redshift có thể thoải mái xử lý giới hạn 1 TB nội dung mới mỗi tháng.   Với 200 yêu cầu đọc trung bình mỗi giây, lưu lượng đọc cho nội dung phổ biến có thể được giải quyết bằng cách mở rộng Bộ nhớ cache , điều này cũng hữu ích để xử lý lưu lượng truy cập được phân bổ không đồng đều và lưu lượng truy cập tăng đột biến.   Bảo mật hệ thống  Mã hóa dữ liệu khi chuyển tiếp và ở trạng thái nghỉ. Sử dụng VPC(Virtual Private Cloud)  Tạo một mạng con công cộng cho Web Server duy nhất để nó có thể gửi và nhận lưu lượng truy cập từ internet. Tạo một mạng con riêng cho mọi thứ khác, ngăn chặn sự truy cập từ bên ngoài. Chỉ mở các cổng từ các IP có trong danh sách cho phép cho phép.      Sắp tới mình sẽ có một bản demo về vấn đề này ở link này. Mình sẽ cố gắng cập nhật sớm nhất.\nKết luận Trên đây chỉ là hiểu biết của mình thông qua việc tìm hiểu module System Design, bản thân mình cũng hi vọng nhận được sự những chia sẻ cũng như thảo luận từ phía các bạn để hoàn thiện hơn. Xin cảm ơn.\nTham khảo system-design-primer\n","date":"2022-05-14T00:00:00Z","image":"https://truongnh28.github.io/p/system-design-project/system_design_huac571d42ebe43b23b89accb8e5d96ee3_114158_120x120_fill_box_smart1_3.png","permalink":"https://truongnh28.github.io/p/system-design-project/","title":"System Design Project"}]